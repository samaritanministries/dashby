"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.withPrefix = withPrefix;
exports.navigateTo = exports.replace = exports.push = exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _keys = _interopRequireDefault(require("@babel/runtime/core-js/object/keys"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _reactRouterDom = require("react-router-dom");

var _reactLifecyclesCompat = require("react-lifecycles-compat");

var _history = require("history");

/*global __PATH_PREFIX__ */
function withPrefix(path) {
  return normalizePath(__PATH_PREFIX__ + "/" + path);
}

function normalizePath(path) {
  return path.replace(/\/+/g, "/");
}

var NavLinkPropTypes = {
  activeClassName: _propTypes.default.string,
  activeStyle: _propTypes.default.object,
  exact: _propTypes.default.bool,
  strict: _propTypes.default.bool,
  isActive: _propTypes.default.func,
  location: _propTypes.default.object // Set up IntersectionObserver

};

var handleIntersection = function handleIntersection(el, cb) {
  var io = new window.IntersectionObserver(function (entries) {
    entries.forEach(function (entry) {
      if (el === entry.target) {
        // Check if element is within viewport, remove listener, destroy observer, and run link callback.
        // MSEdge doesn't currently support isIntersecting, so also test for  an intersectionRatio > 0
        if (entry.isIntersecting || entry.intersectionRatio > 0) {
          io.unobserve(el);
          io.disconnect();
          cb();
        }
      }
    });
  }); // Add element to the observer

  io.observe(el);
};

var GatsbyLink =
/*#__PURE__*/
function (_React$Component) {
  (0, _inheritsLoose2.default)(GatsbyLink, _React$Component);

  function GatsbyLink(props, context) {
    var _this;

    _this = _React$Component.call(this) || this; // Default to no support for IntersectionObserver

    var IOSupported = false;

    if (typeof window !== "undefined" && window.IntersectionObserver) {
      IOSupported = true;
    }

    var location = context.router.history.location;
    var to = (0, _history.createLocation)(props.to, null, null, location);
    _this.state = {
      path: (0, _history.createPath)(to),
      to: to,
      IOSupported: IOSupported,
      location: location
    };
    _this.handleRef = _this.handleRef.bind((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)));
    return _this;
  }

  GatsbyLink.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
    if (prevState.to === nextProps.to) return null;
    var to = (0, _history.createLocation)(nextProps.to, null, null, prevState.location);
    var path = (0, _history.createPath)(to);
    return {
      path: path,
      to: to
    };
  };

  var _proto = GatsbyLink.prototype;

  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
    // Preserve non IO functionality if no support
    if (this.props.to !== prevProps.to && !this.state.IOSupported) {
      ___loader.enqueue(this.state.path);
    }
  };

  _proto.componentDidMount = function componentDidMount() {
    // Preserve non IO functionality if no support
    if (!this.state.IOSupported) {
      ___loader.enqueue(this.state.to.pathname);
    }
  };

  _proto.handleRef = function handleRef(ref) {
    var _this2 = this;

    this.props.innerRef && this.props.innerRef(ref);

    if (this.state.IOSupported && ref) {
      // If IO supported and element reference found, setup Observer functionality
      handleIntersection(ref, function () {
        ___loader.enqueue(_this2.state.to.pathname);
      });
    }
  };

  _proto.render = function render() {
    var _this3 = this;

    var _this$props = this.props,
        _onClick = _this$props.onClick,
        _onMouseEnter = _this$props.onMouseEnter,
        rest = (0, _objectWithoutProperties2.default)(_this$props, ["onClick", "onMouseEnter"]);
    var El;

    if ((0, _keys.default)(NavLinkPropTypes).some(function (propName) {
      return _this3.props[propName];
    })) {
      El = _reactRouterDom.NavLink;
    } else {
      El = _reactRouterDom.Link;
    }

    return _react.default.createElement(El, (0, _extends2.default)({
      onMouseEnter: function onMouseEnter(e) {
        // eslint-disable-line
        _onMouseEnter && _onMouseEnter(e);

        ___loader.hovering(_this3.state.path);
      },
      onClick: function onClick(e) {
        // eslint-disable-line
        _onClick && _onClick(e);

        if (e.button === 0 && // ignore right clicks
        !_this3.props.target && // let browser handle "target=_blank"
        !e.defaultPrevented && // onClick prevented default
        !e.metaKey && // ignore clicks with modifier keys...
        !e.altKey && !e.ctrlKey && !e.shiftKey) {
          // Is this link pointing to a hash on the same page? If so,
          // just scroll there.
          var pathname = _this3.state.path;

          if (pathname.split("#").length > 1) {
            pathname = pathname.split("#").slice(0, -1).join("");
          }

          if (pathname === window.location.pathname) {
            var hashFragment = _this3.state.path.split("#").slice(1).join("#");

            var element = hashFragment ? document.getElementById(hashFragment) : null;

            if (element !== null) {
              element.scrollIntoView();
              return true;
            } else {
              // This is just a normal link to the current page so let's emulate default
              // browser behavior by scrolling now to the top of the page.
              window.scrollTo(0, 0);
              return true;
            }
          } // In production, make sure the necessary scripts are
          // loaded before continuing.


          if (process.env.NODE_ENV === "production") {
            e.preventDefault();

            window.___push(_this3.state.to);
          }
        }

        return true;
      }
    }, rest, {
      to: this.state.to,
      innerRef: this.handleRef
    }));
  };

  return GatsbyLink;
}(_react.default.Component);

GatsbyLink.propTypes = (0, _extends2.default)({}, NavLinkPropTypes, {
  innerRef: _propTypes.default.func,
  onClick: _propTypes.default.func,
  to: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.object]).isRequired
});
GatsbyLink.contextTypes = {
  router: _propTypes.default.object
};

var _default = (0, _reactLifecyclesCompat.polyfill)(GatsbyLink);

exports.default = _default;

var push = function push(to) {
  window.___push(to);
};

exports.push = push;

var replace = function replace(to) {
  window.___replace(to);
}; // TODO: Remove navigateTo for Gatsby v3


exports.replace = replace;

var navigateTo = function navigateTo(to) {
  console.warn("The \"navigateTo\" method is now deprecated and will be removed in Gatsby v3. Please use \"push\" instead.");
  return push(to);
};

exports.navigateTo = navigateTo;