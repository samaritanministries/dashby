{"version":3,"sources":["../../src/utils/websocket-manager.js"],"names":["path","require","store","fs","readCachedResults","dataFileName","directory","filePath","join","JSON","parse","readFileSync","getCachedPageData","pagePath","getState","jsonDataPaths","pages","page","get","dataPath","jsonName","console","log","undefined","result","id","getCachedStaticQueryResults","resultsMap","cachedStaticQueryResults","Map","staticQueryComponents","forEach","staticQueryComponent","has","hash","componentPath","set","getRoomNameFromPath","WebsocketManager","constructor","isInitialised","activePaths","Set","pageResults","staticQueryResults","websocket","programDir","init","bind","getSocket","emitPageData","emitStaticQueryData","server","on","s","activePath","send","type","payload","leaveRoom","leave","leftRoom","sockets","adapter","rooms","length","delete","getDataForPath","why","add","data","manager","module","exports"],"mappings":"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","sourcesContent":["// @flow\n\nconst path = require(`path`)\nconst { store } = require(`../redux`)\nconst fs = require(`fs`)\n\ntype QueryResult = {\n  id: string,\n  result: object,\n}\n\ntype QueryResultsMap = Map<string, QueryResult>\n\n/**\n * Get cached query result for given data path.\n * @param {string} dataFileName Cached query result filename.\n * @param {string} directory Root directory of current project.\n */\nconst readCachedResults = (dataFileName: string, directory: string): object => {\n  const filePath = path.join(\n    directory,\n    `public`,\n    `static`,\n    `d`,\n    `${dataFileName}.json`\n  )\n  return JSON.parse(fs.readFileSync(filePath, `utf-8`))\n}\n\n/**\n * Get cached page query result for given page path.\n * @param {string} pagePath Path to a page.\n * @param {string} directory Root directory of current project.\n */\nconst getCachedPageData = (\n  pagePath: string,\n  directory: string\n): QueryResult => {\n  const { jsonDataPaths, pages } = store.getState()\n  const page = pages.get(pagePath)\n  if (!page) {\n    return null\n  }\n  const dataPath = jsonDataPaths[page.jsonName]\n  if (typeof dataPath === `undefined`) {\n    console.log(\n      `Error loading a result for the page query in \"${pagePath}\". Query was not run and no cached result was found.`\n    )\n    return undefined\n  }\n\n  return {\n    result: readCachedResults(dataPath, directory),\n    id: pagePath,\n  }\n}\n\n/**\n * Get cached StaticQuery results for components that Gatsby didn't run query yet.\n * @param {QueryResultsMap} resultsMap Already stored results for queries that don't need to be read from files.\n * @param {string} directory Root directory of current project.\n */\nconst getCachedStaticQueryResults = (\n  resultsMap: QueryResultsMap,\n  directory: string\n): QueryResultsMap => {\n  const cachedStaticQueryResults = new Map()\n  const { staticQueryComponents, jsonDataPaths } = store.getState()\n  staticQueryComponents.forEach(staticQueryComponent => {\n    // Don't read from file if results were already passed from query runner\n    if (resultsMap.has(staticQueryComponent.hash)) return\n\n    const dataPath = jsonDataPaths[staticQueryComponent.jsonName]\n    if (typeof dataPath === `undefined`) {\n      console.log(\n        `Error loading a result for the StaticQuery in \"${\n          staticQueryComponent.componentPath\n        }\". Query was not run and no cached result was found.`\n      )\n      return\n    }\n    cachedStaticQueryResults.set(staticQueryComponent.hash, {\n      result: readCachedResults(dataPath, directory),\n      id: staticQueryComponent.hash,\n    })\n  })\n  return cachedStaticQueryResults\n}\n\nconst getRoomNameFromPath = (path: string): string => `path-${path}`\n\nclass WebsocketManager {\n  pageResults: QueryResultsMap\n  staticQueryResults: QueryResultsMap\n  isInitialised: boolean\n  activePaths: Set<string>\n  programDir: string\n\n  constructor() {\n    this.isInitialised = false\n    this.activePaths = new Set()\n    this.pageResults = new Map()\n    this.staticQueryResults = new Map()\n    this.websocket\n    this.programDir\n\n    this.init = this.init.bind(this)\n    this.getSocket = this.getSocket.bind(this)\n    this.emitPageData = this.emitPageData.bind(this)\n    this.emitStaticQueryData = this.emitStaticQueryData.bind(this)\n  }\n\n  init({ server, directory }) {\n    this.programDir = directory\n\n    const cachedStaticQueryResults = getCachedStaticQueryResults(\n      this.staticQueryResults,\n      this.programDir\n    )\n    this.staticQueryResults = new Map([\n      ...this.staticQueryResults,\n      ...cachedStaticQueryResults,\n    ])\n\n    this.websocket = require(`socket.io`)(server)\n\n    this.websocket.on(`connection`, s => {\n      let activePath = null\n      // Send already existing static query results\n      this.staticQueryResults.forEach(result => {\n        this.websocket.send({\n          type: `staticQueryResult`,\n          payload: result,\n        })\n      })\n\n      const leaveRoom = path => {\n        s.leave(getRoomNameFromPath(path))\n        const leftRoom = this.websocket.sockets.adapter.rooms[\n          getRoomNameFromPath(path)\n        ]\n        if (!leftRoom || leftRoom.length === 0) {\n          this.activePaths.delete(path)\n        }\n      }\n\n      const getDataForPath = path => {\n        if (!this.pageResults.has(path)) {\n          const result = getCachedPageData(path, this.programDir)\n          if (result) {\n            this.pageResults.set(path, result)\n          } else {\n            console.log(`Page not found`, path)\n            return\n          }\n        }\n\n        this.websocket.send({\n          type: `pageQueryResult`,\n          why: `getDataForPath`,\n          payload: this.pageResults.get(path),\n        })\n      }\n\n      s.on(`getDataForPath`, getDataForPath)\n\n      s.on(`registerPath`, path => {\n        s.join(getRoomNameFromPath(path))\n        activePath = path\n        this.activePaths.add(path)\n      })\n\n      s.on(`disconnect`, s => {\n        leaveRoom(activePath)\n      })\n\n      s.on(`unregisterPath`, path => {\n        leaveRoom(path)\n      })\n    })\n\n    this.isInitialised = true\n  }\n\n  getSocket() {\n    return this.isInitialised && this.websocket\n  }\n\n  emitStaticQueryData(data: QueryResult) {\n    this.staticQueryResults.set(data.id, data)\n    if (this.isInitialised) {\n      this.websocket.send({ type: `staticQueryResult`, payload: data })\n    }\n  }\n\n  emitPageData(data: QueryResult) {\n    if (this.isInitialised) {\n      this.websocket.send({ type: `pageQueryResult`, payload: data })\n    }\n    this.pageResults.set(data.id, data)\n  }\n}\n\nconst manager = new WebsocketManager()\n\nmodule.exports = manager\n"],"file":"websocket-manager.js"}