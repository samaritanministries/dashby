{"version":3,"sources":["../../src/schema/build-connection-fields.js"],"names":["_","require","GraphQLInt","GraphQLList","GraphQLString","GraphQLEnumType","connectionArgs","connectionDefinitions","connectionFromArray","buildFieldEnumValues","module","exports","type","enumValues","nodes","typeName","name","camelCase","nodeType","nodeObjectType","connectionFields","field","fieldValue","totalCount","groupConnection","connectionType","distinct","args","values","resolve","connection","fieldName","includes","replace","fields","edges","map","edge","get","node","sortBy","filter","uniq","flatten","identity","group","connectionNodes","groups","isArray","find","reduce","vals","n","has","concat","forEach","val","groupBy","groupConnections","sortedFieldValues","keys","each","groupNodes","groupConn","length","push"],"mappings":"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","sourcesContent":["// @flow\nconst _ = require(`lodash`)\nconst {\n  GraphQLInt,\n  GraphQLList,\n  GraphQLString,\n  GraphQLEnumType,\n} = require(`graphql`)\nconst {\n  connectionArgs,\n  connectionDefinitions,\n  connectionFromArray,\n} = require(`graphql-skip-limit`)\n\nconst { buildFieldEnumValues } = require(`./data-tree-utils`)\n\nmodule.exports = type => {\n  const enumValues = buildFieldEnumValues({\n    nodes: type.nodes,\n    typeName: type.name,\n  })\n  const { connectionType: groupConnection } = connectionDefinitions({\n    name: _.camelCase(`${type.name} groupConnection`),\n    nodeType: type.nodeObjectType,\n    connectionFields: () => {\n      return {\n        field: { type: GraphQLString },\n        fieldValue: { type: GraphQLString },\n        totalCount: { type: GraphQLInt },\n      }\n    },\n  })\n\n  return {\n    totalCount: {\n      type: GraphQLInt,\n    },\n    distinct: {\n      type: new GraphQLList(GraphQLString),\n      args: {\n        field: {\n          type: new GraphQLEnumType({\n            name: _.camelCase(`${type.name} distinct enum`),\n            values: enumValues,\n          }),\n        },\n      },\n      resolve(connection, args) {\n        let fieldName = args.field\n        if (_.includes(args.field, `___`)) {\n          fieldName = args.field.replace(/___/g, `.`)\n        }\n        const fields = connection.edges.map(edge => _.get(edge.node, fieldName))\n        return _.sortBy(_.filter(_.uniq(_.flatten(fields)), _.identity))\n      },\n    },\n    group: {\n      type: new GraphQLList(groupConnection),\n      args: {\n        ...connectionArgs,\n        field: {\n          type: new GraphQLEnumType({\n            name: _.camelCase(`${type.name} group enum`),\n            values: enumValues,\n          }),\n        },\n      },\n      resolve(connection, args) {\n        const fieldName = args.field.replace(/___/g, `.`)\n        const connectionNodes = connection.edges.map(edge => edge.node)\n\n        let groups = {}\n        // Do a custom grouping for arrays (w/ a group per array value)\n        // Find the first node with this field and check if it's an array.\n        if (_.isArray(_.get(_.find(connectionNodes, fieldName), fieldName))) {\n          const values = _.uniq(\n            _.reduce(\n              connectionNodes,\n              (vals, n) => {\n                if (_.has(n, fieldName)) {\n                  return vals.concat(_.get(n, fieldName))\n                } else {\n                  return vals\n                }\n              },\n              []\n            )\n          )\n          values.forEach(val => {\n            groups[val] = _.filter(connectionNodes, n =>\n              _.includes(_.get(n, fieldName), val)\n            )\n          })\n        } else {\n          groups = _.groupBy(connectionNodes, fieldName)\n        }\n        const groupConnections = []\n\n        // Do default sort by fieldValue\n        const sortedFieldValues = _.sortBy(_.keys(groups))\n        _.each(sortedFieldValues, fieldValue => {\n          const groupNodes = groups[fieldValue]\n          const groupConn = connectionFromArray(groupNodes, args)\n          groupConn.totalCount = groupNodes.length\n          groupConn.field = fieldName\n          groupConn.fieldValue = fieldValue\n          groupConnections.push(groupConn)\n        })\n\n        return groupConnections\n      },\n    },\n  }\n}\n"],"file":"build-connection-fields.js"}