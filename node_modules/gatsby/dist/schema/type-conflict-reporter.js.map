{"version":3,"sources":["../../src/schema/type-conflict-reporter.js"],"names":["_","require","report","typeOf","util","findRootNodeAncestor","isNodeWithDescription","node","internal","description","findNodeDescription","obj","formatValue","value","isArray","inspect","colors","depth","breakLength","Infinity","wasElipsisLast","usedTypes","output","forEach","item","type","indexOf","push","join","TypeConflictEntry","constructor","selector","types","Map","addExample","parent","set","printEntry","sortedByTypeName","sortBy","Array","from","entries","typeName","log","map","TypeConflictReporter","clearConflicts","clear","getEntryFromSelector","dataEntry","get","addConflict","examples","substring","entry","filter","example","printConflicts","size","warn","typeConflictReporter","module","exports"],"mappings":"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","sourcesContent":["// @flow\nconst _ = require(`lodash`)\nconst report = require(`gatsby-cli/lib/reporter`)\nconst typeOf = require(`type-of`)\nconst util = require(`util`)\nconst { findRootNodeAncestor } = require(`./node-tracking`)\n\nexport type TypeConflictExample = {\n  value: mixed,\n  parent: {},\n  type: string,\n  arrayTypes: string[],\n}\n\ntype TypeConflict = {\n  value: mixed,\n  description: string,\n}\n\nconst isNodeWithDescription = node =>\n  node && node.internal && node.internal.description\n\nconst findNodeDescription = obj => {\n  if (obj) {\n    const node = findRootNodeAncestor(obj, isNodeWithDescription)\n    if (isNodeWithDescription(node)) {\n      return node.internal.description\n    }\n  }\n  return ``\n}\n\nconst formatValue = value => {\n  if (!_.isArray(value)) {\n    return util.inspect(value, {\n      colors: true,\n      depth: 0,\n      breakLength: Infinity,\n    })\n  }\n\n  let wasElipsisLast = false\n  const usedTypes = []\n  const output = []\n\n  value.forEach(item => {\n    const type = typeOf(item)\n    if (usedTypes.indexOf(type) !== -1) {\n      if (!wasElipsisLast) {\n        output.push(`...`)\n        wasElipsisLast = true\n      }\n    } else {\n      output.push(formatValue(item))\n      wasElipsisLast = false\n      usedTypes.push(type)\n    }\n  })\n\n  return `[ ${output.join(`, `)} ]`\n}\n\nclass TypeConflictEntry {\n  selector: string\n  types: Map<string, TypeConflict>\n\n  constructor(selector: string) {\n    this.selector = selector\n    this.types = new Map()\n  }\n\n  addExample({ value, type, parent }: TypeConflictExample) {\n    this.types.set(type, {\n      value,\n      description: findNodeDescription(parent),\n    })\n  }\n\n  printEntry() {\n    const sortedByTypeName = _.sortBy(\n      Array.from(this.types.entries()),\n      ([typeName, value]) => typeName\n    )\n\n    report.log(\n      `${this.selector}:${sortedByTypeName\n        .map(\n          ([typeName, { value, description }]) =>\n            `\\n - type: ${typeName}\\n   value: ${formatValue(\n              value\n            )}${description && `\\n   source: ${description}`}`\n        )\n        .join(``)}`\n    )\n  }\n}\n\nclass TypeConflictReporter {\n  entries: Map<string, TypeConflictEntry>\n\n  constructor() {\n    this.entries = new Map()\n  }\n\n  clearConflicts() {\n    this.entries.clear()\n  }\n\n  getEntryFromSelector(selector: string): TypeConflictEntry {\n    let dataEntry = this.entries.get(selector)\n\n    if (!dataEntry) {\n      dataEntry = new TypeConflictEntry(selector)\n      this.entries.set(selector, dataEntry)\n    }\n\n    return dataEntry\n  }\n\n  addConflict(selector: string, examples: TypeConflictExample[]) {\n    if (selector.substring(0, 11) === `SitePlugin.`) {\n      // Don't store and print out type conflicts in plugins.\n      // This is out of user control so he can't do anything\n      // to hide those.\n      return\n    }\n\n    const entry = this.getEntryFromSelector(selector)\n    examples\n      .filter(example => example.value != null)\n      .forEach(example => entry.addExample(example))\n  }\n\n  printConflicts() {\n    if (this.entries.size > 0) {\n      report.warn(\n        `There are conflicting field types in your data. GraphQL schema will omit those fields.`\n      )\n      this.entries.forEach(entry => entry.printEntry())\n    }\n  }\n}\n\nconst typeConflictReporter = new TypeConflictReporter()\n\nconst printConflicts = () => {\n  typeConflictReporter.printConflicts()\n}\n\nmodule.exports = { typeConflictReporter, printConflicts, TypeConflictEntry }\n"],"file":"type-conflict-reporter.js"}