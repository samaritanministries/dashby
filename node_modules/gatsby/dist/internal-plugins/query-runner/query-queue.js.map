{"version":3,"sources":["../../../src/internal-plugins/query-runner/query-queue.js"],"names":["Queue","require","queryRunner","store","emitter","websocketManager","processing","Set","waiting","Map","queueOptions","concurrent","merge","oldTask","newTask","cb","priority","job","activePaths","Array","from","values","id","includes","filter","has","set","process","env","gatsby_executing_command","queue","plObj","callback","state","getState","add","components","component","catch","e","console","log","then","result","delete","push","get","error","on","emit","module","exports"],"mappings":";;AAAA,MAAMA,QAAQC,QAAS,cAAT,CAAd;;AAEA,MAAMC,cAAcD,QAAS,gBAAT,CAApB;;iBAC2BA,QAAS,aAAT,C;MAAnBE,K,YAAAA,K;MAAOC,O,YAAAA,O;;AACf,MAAMC,mBAAmBJ,QAAS,+BAAT,CAAzB;;AAEA,MAAMK,aAAa,IAAIC,GAAJ,EAAnB;AACA,MAAMC,UAAU,IAAIC,GAAJ,EAAhB;AAEA,MAAMC,eAAe;AACnBC,cAAY,CADO;AAEnB;AACAC,SAAO,CAACC,OAAD,EAAUC,OAAV,EAAmBC,EAAnB,KAA0B;AAC/BA,OAAG,IAAH,EAASD,OAAT;AACD,GALkB;AAMnBE,YAAU,CAACC,GAAD,EAAMF,EAAN,KAAa;AACrB,UAAMG,cAAcC,MAAMC,IAAN,CAAWf,iBAAiBa,WAAjB,CAA6BG,MAA7B,EAAX,CAApB;;AACA,QAAIJ,IAAIK,EAAJ,IAAUJ,YAAYK,QAAZ,CAAqBN,IAAIK,EAAzB,CAAd,EAA4C;AAC1CP,SAAG,IAAH,EAAS,EAAT;AACD,KAFD,MAEO;AACLA,SAAG,IAAH,EAAS,CAAT;AACD;AACF,GAbkB;AAcnB;AACA;AACA;AACAS,UAAQ,CAACP,GAAD,EAAMF,EAAN,KAAa;AACnB,QAAIT,WAAWmB,GAAX,CAAeR,IAAIK,EAAnB,CAAJ,EAA4B;AAC1Bd,cAAQkB,GAAR,CAAYT,IAAIK,EAAhB,EAAoBL,GAApB;AACAF,SAAI,iBAAJ;AACD,KAHD,MAGO;AACLA,SAAG,IAAH,EAASE,GAAT;AACD;AACF,GAxBkB,CA2BrB;AACA;;AA5BqB,CAArB;;AA6BA,IAAIU,QAAQC,GAAR,CAAYC,wBAAZ,KAA0C,OAA9C,EAAsD;AACpD,SAAOnB,aAAac,MAApB;AACA,SAAOd,aAAaM,QAApB;AACA,SAAON,aAAaE,KAApB;AACD;;AAED,MAAMkB,QAAQ,IAAI9B,KAAJ,CAAU,CAAC+B,KAAD,EAAQC,QAAR,KAAqB;AAC3C,QAAMC,QAAQ9B,MAAM+B,QAAN,EAAd;AACA5B,aAAW6B,GAAX,CAAeJ,MAAMT,EAArB;AAEA,SAAOpB,YAAY6B,KAAZ,EAAmBE,MAAMG,UAAN,CAAiBL,MAAMM,SAAvB,CAAnB,EACJC,KADI,CACEC,KAAKC,QAAQC,GAAR,CAAa,2BAAb,EAAyCF,CAAzC,CADP,EAEJG,IAFI,CAGHC,UAAU;AACRrC,eAAWsC,MAAX,CAAkBb,MAAMT,EAAxB;;AACA,QAAId,QAAQiB,GAAR,CAAYM,MAAMT,EAAlB,CAAJ,EAA2B;AACzBQ,YAAMe,IAAN,CAAWrC,QAAQsC,GAAR,CAAYf,MAAMT,EAAlB,CAAX;AACAd,cAAQoC,MAAR,CAAeb,MAAMT,EAArB;AACD;;AACD,WAAOU,SAAS,IAAT,EAAeW,MAAf,CAAP;AACD,GAVE,EAWHI,SAASf,SAASe,KAAT,CAXN,CAAP;AAaD,CAjBa,EAiBXrC,YAjBW,CAAd;AAmBAoB,MAAMkB,EAAN,CAAU,OAAV,EAAkB,MAAM;AACtB5C,UAAQ6C,IAAR,CAAc,qBAAd;AACD,CAFD;AAIAC,OAAOC,OAAP,GAAiBrB,KAAjB","sourcesContent":["const Queue = require(`better-queue`)\n\nconst queryRunner = require(`./query-runner`)\nconst { store, emitter } = require(`../../redux`)\nconst websocketManager = require(`../../utils/websocket-manager`)\n\nconst processing = new Set()\nconst waiting = new Map()\n\nconst queueOptions = {\n  concurrent: 4,\n  // Merge duplicate jobs.\n  merge: (oldTask, newTask, cb) => {\n    cb(null, newTask)\n  },\n  priority: (job, cb) => {\n    const activePaths = Array.from(websocketManager.activePaths.values())\n    if (job.id && activePaths.includes(job.id)) {\n      cb(null, 10)\n    } else {\n      cb(null, 1)\n    }\n  },\n  // Filter out new query jobs if that query is already running.  When the\n  // query finshes, it checks the waiting map and pushes another job to\n  // make sure all the user changes are captured.\n  filter: (job, cb) => {\n    if (processing.has(job.id)) {\n      waiting.set(job.id, job)\n      cb(`already running`)\n    } else {\n      cb(null, job)\n    }\n  },\n}\n\n// During builds we don't need all the filtering, etc. so we\n// remove them to speed up queries\nif (process.env.gatsby_executing_command === `build`) {\n  delete queueOptions.filter\n  delete queueOptions.priority\n  delete queueOptions.merge\n}\n\nconst queue = new Queue((plObj, callback) => {\n  const state = store.getState()\n  processing.add(plObj.id)\n\n  return queryRunner(plObj, state.components[plObj.component])\n    .catch(e => console.log(`Error running queryRunner`, e))\n    .then(\n      result => {\n        processing.delete(plObj.id)\n        if (waiting.has(plObj.id)) {\n          queue.push(waiting.get(plObj.id))\n          waiting.delete(plObj.id)\n        }\n        return callback(null, result)\n      },\n      error => callback(error)\n    )\n}, queueOptions)\n\nqueue.on(`drain`, () => {\n  emitter.emit(`QUERY_QUEUE_DRAINED`)\n})\n\nmodule.exports = queue\n"],"file":"query-queue.js"}