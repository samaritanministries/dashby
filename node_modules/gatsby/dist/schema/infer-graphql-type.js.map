{"version":3,"sources":["../../src/schema/infer-graphql-type.js"],"names":["require","GraphQLObjectType","GraphQLBoolean","GraphQLString","GraphQLFloat","GraphQLInt","GraphQLList","GraphQLUnionType","_","invariant","oneLine","store","getNode","getNodes","createPageDependency","createTypeName","createKey","getExampleValues","isEmptyObjectOrArray","DateType","FileType","is32BitInteger","inferGraphQLType","exampleValue","selector","nodes","types","otherArgs","fieldName","split","pop","shouldInfer","isArray","getListType","getType","Array","inferredType","type","args","resolve","listType","object","context","resolveInfo","fieldValue","map","value","name","fields","_inferObjectStructureFromNodes","inferFromMapping","mapping","fieldSelector","linkedType","linkedField","slice","length","matchedTypes","filter","isEmpty","console","log","findNode","path","linkedNode","find","n","internal","get","nodeId","id","nodeObjectType","node","a","b","findLinkedNode","inferFromFieldName","uniqBy","v","key","validateLinkedNode","validateField","field","findNodeType","linkedNodes","forEach","i","f","sort","join","description","resolveType","data","result","EXCLUDE_KEYS","parent","children","ignoreFields","config","getState","isRoot","typeName","resolvedExample","inferredFields","each","nextSelector","inferredField","includes","Object","keys","sanitizedFieldName","fieldResolve","inferredFieldWithoutResolve","source","inferObjectStructureFromNodes","options"],"mappings":"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","sourcesContent":["// @flow\nconst {\n  GraphQLObjectType,\n  GraphQLBoolean,\n  GraphQLString,\n  GraphQLFloat,\n  GraphQLInt,\n  GraphQLList,\n  GraphQLUnionType,\n} = require(`graphql`)\nconst _ = require(`lodash`)\nconst invariant = require(`invariant`)\nconst { oneLine } = require(`common-tags`)\n\nconst { store, getNode, getNodes } = require(`../redux`)\nconst { createPageDependency } = require(`../redux/actions/add-page-dependency`)\nconst createTypeName = require(`./create-type-name`)\nconst createKey = require(`./create-key`)\nconst { getExampleValues, isEmptyObjectOrArray } = require(`./data-tree-utils`)\nconst DateType = require(`./types/type-date`)\nconst FileType = require(`./types/type-file`)\nconst is32BitInteger = require(`../utils/is-32-bit-integer`)\n\nimport type { GraphQLOutputType } from \"graphql\"\nimport type {\n  GraphQLFieldConfig,\n  GraphQLFieldConfigMap,\n} from \"graphql/type/definition\"\n\nexport type ProcessedNodeType = {\n  name: string,\n  nodes: any[],\n  node: GraphQLFieldConfig<*, *>,\n  fieldsFromPlugins: any,\n  nodeObjectType: GraphQLOutputType,\n}\n\nfunction inferGraphQLType({\n  exampleValue,\n  selector,\n  nodes,\n  types,\n  ...otherArgs\n}): ?GraphQLFieldConfig<*, *> {\n  if (exampleValue == null || isEmptyObjectOrArray(exampleValue)) return null\n  let fieldName = selector.split(`.`).pop()\n\n  // Check this before checking for array as FileType has\n  // builtin support for inferring array of files and inferred\n  // array type will have faster resolver than resolving array\n  // of files separately.\n  if (FileType.shouldInfer(nodes, selector, exampleValue)) {\n    return _.isArray(exampleValue) ? FileType.getListType() : FileType.getType()\n  }\n\n  if (Array.isArray(exampleValue)) {\n    exampleValue = exampleValue[0]\n\n    if (exampleValue == null) return null\n\n    let inferredType = inferGraphQLType({\n      ...otherArgs,\n      exampleValue,\n      selector,\n      nodes,\n      types,\n    })\n    invariant(\n      inferredType,\n      `Could not infer graphQL type for value: ${exampleValue}`\n    )\n\n    const { type, args = null, resolve = null } = inferredType\n\n    const listType = { type: new GraphQLList(type), args }\n\n    if (resolve) {\n      // If inferredType has resolve function wrap it with Array.map\n      listType.resolve = (object, args, context, resolveInfo) => {\n        const fieldValue = object[fieldName]\n        if (!fieldValue) {\n          return null\n        }\n\n        // Field resolver expects first parameter to be plain object\n        // containing key with name of field we want to resolve.\n        return fieldValue.map(value =>\n          resolve({ [fieldName]: value }, args, context, resolveInfo)\n        )\n      }\n    }\n\n    return listType\n  }\n\n  if (DateType.shouldInfer(exampleValue)) {\n    return DateType.getType()\n  }\n\n  switch (typeof exampleValue) {\n    case `boolean`:\n      return { type: GraphQLBoolean }\n    case `string`:\n      return { type: GraphQLString }\n    case `object`:\n      return {\n        type: new GraphQLObjectType({\n          name: createTypeName(fieldName),\n          fields: _inferObjectStructureFromNodes(\n            {\n              ...otherArgs,\n              selector,\n              nodes,\n              types,\n            },\n            exampleValue\n          ),\n        }),\n      }\n    case `number`:\n      return is32BitInteger(exampleValue)\n        ? { type: GraphQLInt }\n        : { type: GraphQLFloat }\n    default:\n      return null\n  }\n}\n\nfunction inferFromMapping(\n  value,\n  mapping,\n  fieldSelector,\n  types\n): ?GraphQLFieldConfig<*, *> {\n  const linkedType = mapping[fieldSelector].split(`.`)[0]\n  const linkedField =\n    mapping[fieldSelector].slice(linkedType.length + 1) || `id`\n\n  const matchedTypes = types.filter(type => type.name === linkedType)\n  if (_.isEmpty(matchedTypes)) {\n    console.log(`Couldn't find a matching node type for \"${fieldSelector}\"`)\n    return null\n  }\n\n  const findNode = (fieldValue, path) => {\n    const linkedNode = _.find(\n      getNodes(),\n      n =>\n        n.internal.type === linkedType && _.get(n, linkedField) === fieldValue\n    )\n    if (linkedNode) {\n      createPageDependency({ path, nodeId: linkedNode.id })\n      return linkedNode\n    }\n    return null\n  }\n\n  if (_.isArray(value)) {\n    return {\n      type: new GraphQLList(matchedTypes[0].nodeObjectType),\n      resolve: (node, a, b, { fieldName }) => {\n        const fieldValue = node[fieldName]\n\n        if (fieldValue) {\n          return fieldValue.map(value => findNode(value, b.path))\n        } else {\n          return null\n        }\n      },\n    }\n  }\n\n  return {\n    type: matchedTypes[0].nodeObjectType,\n    resolve: (node, a, b, { fieldName }) => {\n      const fieldValue = node[fieldName]\n\n      if (fieldValue) {\n        return findNode(fieldValue, b.path)\n      } else {\n        return null\n      }\n    },\n  }\n}\n\nexport function findLinkedNode(value, linkedField, path) {\n  let linkedNode\n  // If the field doesn't link to the id, use that for searching.\n  if (linkedField) {\n    linkedNode = getNodes().find(n => n[linkedField] === value)\n    // Else the field is linking to the node's id, the default.\n  } else {\n    linkedNode = getNode(value)\n  }\n\n  if (linkedNode) {\n    if (path) createPageDependency({ path, nodeId: linkedNode.id })\n    return linkedNode\n  }\n  return null\n}\n\nfunction inferFromFieldName(value, selector, types): GraphQLFieldConfig<*, *> {\n  let isArray = false\n  if (_.isArray(value)) {\n    isArray = true\n    // Reduce values to nodes with unique types.\n    value = _.uniqBy(value, v => getNode(v).internal.type)\n  }\n\n  const key = selector.split(`.`).pop()\n  const [, , linkedField] = key.split(`___`)\n\n  const validateLinkedNode = linkedNode => {\n    invariant(\n      linkedNode,\n      oneLine`\n        Encountered an error trying to infer a GraphQL type for: \"${selector}\".\n        There is no corresponding node with the ${linkedField || `id`}\n        field matching: \"${value}\"\n      `\n    )\n  }\n  const validateField = (linkedNode, field) => {\n    invariant(\n      field,\n      oneLine`\n        Encountered an error trying to infer a GraphQL type for: \"${selector}\".\n        There is no corresponding GraphQL type \"${\n          linkedNode.internal.type\n        }\" available\n        to link to this node.\n      `\n    )\n  }\n\n  const findNodeType = node =>\n    types.find(type => type.name === node.internal.type)\n\n  if (isArray) {\n    const linkedNodes = value.map(v => findLinkedNode(v))\n    linkedNodes.forEach(node => validateLinkedNode(node))\n    const fields = linkedNodes.map(node => findNodeType(node))\n    fields.forEach((field, i) => validateField(linkedNodes[i], field))\n\n    let type\n    // If there's more than one type, we'll create a union type.\n    if (fields.length > 1) {\n      type = new GraphQLUnionType({\n        name: createTypeName(\n          `Union_${key}_${fields\n            .map(f => f.name)\n            .sort()\n            .join(`__`)}`\n        ),\n        description: `Union interface for the field \"${key}\" for types [${fields\n          .map(f => f.name)\n          .sort()\n          .join(`, `)}]`,\n        types: fields.map(f => f.nodeObjectType),\n        resolveType: data =>\n          fields.find(f => f.name == data.internal.type).nodeObjectType,\n      })\n    } else {\n      type = fields[0].nodeObjectType\n    }\n\n    return {\n      type: new GraphQLList(type),\n      resolve: (node, a, b = {}) => {\n        let fieldValue = node[key]\n        if (fieldValue) {\n          return fieldValue.map(value =>\n            findLinkedNode(value, linkedField, b.path)\n          )\n        } else {\n          return null\n        }\n      },\n    }\n  }\n\n  const linkedNode = findLinkedNode(value, linkedField)\n  validateLinkedNode(linkedNode)\n  const field = findNodeType(linkedNode)\n  validateField(linkedNode, field)\n  return {\n    type: field.nodeObjectType,\n    resolve: (node, a, b = {}) => {\n      let fieldValue = node[key]\n      if (fieldValue) {\n        const result = findLinkedNode(fieldValue, linkedField, b.path)\n        return result\n      } else {\n        return null\n      }\n    },\n  }\n}\n\ntype inferTypeOptions = {\n  nodes: Object[],\n  types: ProcessedNodeType[],\n  ignoreFields?: string[],\n  selector?: string,\n}\n\nconst EXCLUDE_KEYS = {\n  id: 1,\n  parent: 1,\n  children: 1,\n}\n\n// Call this for the top level node + recursively for each sub-object.\n// E.g. This gets called for Markdown and then for its frontmatter subobject.\nfunction _inferObjectStructureFromNodes(\n  { nodes, types, selector, ignoreFields }: inferTypeOptions,\n  exampleValue: ?Object\n): GraphQLFieldConfigMap<*, *> {\n  const config = store.getState().config\n  const isRoot = !selector\n  const mapping = config && config.mapping\n\n  // Ensure nodes have internal key with object.\n  nodes = nodes.map(n => (n.internal ? n : { ...n, internal: {} }))\n\n  const typeName: string = nodes[0].internal.type\n\n  let resolvedExample: Object =\n    exampleValue != null\n      ? exampleValue\n      : getExampleValues({ nodes, typeName, ignoreFields })\n\n  const inferredFields = {}\n  _.each(resolvedExample, (value, key) => {\n    // Remove fields common to the top-level of all nodes.  We add these\n    // elsewhere so don't need to infer their type.\n    if (isRoot && EXCLUDE_KEYS[key]) return\n\n    // Several checks to see if a field is pointing to custom type\n    // before we try automatic inference.\n    const nextSelector = selector ? `${selector}.${key}` : key\n    const fieldSelector = `${typeName}.${nextSelector}`\n\n    let fieldName = key\n    let inferredField\n\n    // First check for manual field => type mappings in the site's\n    // gatsby-config.js\n    if (mapping && _.includes(Object.keys(mapping), fieldSelector)) {\n      inferredField = inferFromMapping(value, mapping, fieldSelector, types)\n\n      // Second if the field has a suffix of ___node. We use then the value\n      // (a node id) to find the node and use that node's type as the field\n    } else if (key.includes(`___NODE`)) {\n      ;[fieldName] = key.split(`___`)\n      inferredField = inferFromFieldName(value, nextSelector, types)\n    }\n\n    // Replace unsupported values\n    const sanitizedFieldName = createKey(fieldName)\n\n    // If a pluging has already provided a type for this, don't infer it.\n    if (ignoreFields && ignoreFields.includes(sanitizedFieldName)) {\n      return\n    }\n\n    // Finally our automatic inference of field value type.\n    if (!inferredField) {\n      inferredField = inferGraphQLType({\n        nodes,\n        types,\n        exampleValue: value,\n        selector: nextSelector,\n      })\n    }\n\n    if (!inferredField) return\n\n    // If sanitized field name is different from original field name\n    // add resolve passthrough to reach value using original field name\n    if (sanitizedFieldName !== fieldName) {\n      const {\n        resolve: fieldResolve,\n        ...inferredFieldWithoutResolve\n      } = inferredField\n\n      // Using copy if field as we sometimes have predefined frozen\n      // field definitions and we can't mutate them.\n      inferredField = inferredFieldWithoutResolve\n\n      if (fieldResolve) {\n        // If field has resolver, call it with adjusted resolveInfo\n        // that points to original field name\n        inferredField.resolve = (source, args, context, resolveInfo) =>\n          fieldResolve(source, args, context, {\n            ...resolveInfo,\n            fieldName: fieldName,\n          })\n      } else {\n        inferredField.resolve = source => source[fieldName]\n      }\n    }\n\n    inferredFields[sanitizedFieldName] = inferredField\n  })\n\n  return inferredFields\n}\n\nexport function inferObjectStructureFromNodes(options: inferTypeOptions) {\n  return _inferObjectStructureFromNodes(options, null)\n}\n"],"file":"infer-graphql-type.js"}