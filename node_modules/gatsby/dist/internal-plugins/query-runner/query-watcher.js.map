{"version":3,"sources":["../../../src/internal-plugins/query-runner/query-watcher.js"],"names":["_","require","chokidar","path","slash","store","emitter","boundActionCreators","queryCompiler","default","report","queueQueryForPathname","runQueuedQueries","runQueuedActions","debug","getQueriesSnapshot","state","getState","snapshot","components","Map","staticQueryComponents","handleComponentsWithRemovedQueries","queries","forEach","c","query","has","componentPath","replaceComponentQuery","queueQueriesForPageComponent","dispatch","type","payload","jsonName","deleteComponentsDependencies","handleQuery","component","isStaticQuery","isNewQuery","get","text","replaceStaticQuery","name","id","hash","length","updateStateAndRunQueries","isFirstRun","then","queriesWillNotRun","queryWillRun","watchComponent","warn","log","stripIndent","clearInactiveComponents","pages","activeTemplates","Set","page","add","exports","extractQueries","process","env","NODE_ENV","watch","program","directory","getPagesForComponent","map","p","values","filter","filesToWatch","watcher","rootDir","debounceCompile","debounce","join","on","filePath","gatsby_executing_command","bootstrapFinished","action","otherPageWithTemplateExists"],"mappings":"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","sourcesContent":["/** *\n * Jobs of this module\n * - Maintain the list of components in the Redux store. So monitor new components\n *   and add/remove components.\n * - Watch components for query changes and extract these and update the store.\n * - Ensure all page queries are run as part of bootstrap and report back when\n *   this is done\n * - Whenever a query changes, re-run all pages that rely on this query.\n ***/\n\nconst _ = require(`lodash`)\nconst chokidar = require(`chokidar`)\nconst path = require(`path`)\nconst slash = require(`slash`)\n\nconst { store, emitter } = require(`../../redux/`)\nconst { boundActionCreators } = require(`../../redux/actions`)\nconst queryCompiler = require(`./query-compiler`).default\nconst report = require(`gatsby-cli/lib/reporter`)\nconst {\n  queueQueryForPathname,\n  runQueuedActions: runQueuedQueries,\n} = require(`./page-query-runner`)\nconst debug = require(`debug`)(`gatsby:query-watcher`)\n\nconst getQueriesSnapshot = () => {\n  const state = store.getState()\n\n  const snapshot = {\n    components: new Map(state.components),\n    staticQueryComponents: new Map(state.staticQueryComponents),\n  }\n\n  return snapshot\n}\n\nconst handleComponentsWithRemovedQueries = (\n  { components, staticQueryComponents },\n  queries\n) => {\n  // If a component previously with a query now doesn't â€” update the\n  // store.\n  components.forEach(c => {\n    if (c.query !== `` && !queries.has(c.componentPath)) {\n      debug(`Page query was removed from ${c.componentPath}`)\n      boundActionCreators.replaceComponentQuery({\n        query: ``,\n        componentPath: c.componentPath,\n      })\n      queueQueriesForPageComponent(c.componentPath)\n    }\n  })\n\n  // If a component had static query and it doesn't have it\n  // anymore - update the store\n  staticQueryComponents.forEach(c => {\n    if (c.query !== `` && !queries.has(c.componentPath)) {\n      debug(`Static query was removed from ${c.componentPath}`)\n      store.dispatch({\n        type: `REMOVE_STATIC_QUERY`,\n        payload: c.jsonName,\n      })\n      boundActionCreators.deleteComponentsDependencies([c.jsonName])\n    }\n  })\n}\n\nconst handleQuery = (\n  { components, staticQueryComponents },\n  query,\n  component\n) => {\n  // If this is a static query\n  // Add action / reducer + watch staticquery files\n  if (query.isStaticQuery) {\n    const isNewQuery = !staticQueryComponents.has(query.jsonName)\n    if (\n      isNewQuery ||\n      staticQueryComponents.get(query.jsonName).query !== query.text\n    ) {\n      boundActionCreators.replaceStaticQuery({\n        name: query.name,\n        componentPath: query.path,\n        id: query.jsonName,\n        jsonName: query.jsonName,\n        query: query.text,\n        hash: query.hash,\n      })\n\n      debug(\n        `Static query in ${component} ${\n          isNewQuery ? `was added` : `has changed`\n        }.`\n      )\n\n      boundActionCreators.deleteComponentsDependencies([query.jsonName])\n      queueQueryForPathname(query.jsonName)\n    }\n    return true\n\n    // If this is page query\n  } else if (components.has(component)) {\n    if (components.get(component).query !== query.text) {\n      boundActionCreators.replaceComponentQuery({\n        query: query.text,\n        componentPath: component,\n      })\n\n      debug(\n        `Page query in ${component} ${\n          components.get(component).query.length === 0\n            ? `was added`\n            : `has changed`\n        }.`\n      )\n      queueQueriesForPageComponent(component)\n    }\n    return true\n  }\n\n  return false\n}\n\nconst updateStateAndRunQueries = isFirstRun => {\n  const snapshot = getQueriesSnapshot()\n  return queryCompiler().then(queries => {\n    handleComponentsWithRemovedQueries(snapshot, queries)\n\n    let queriesWillNotRun = false\n    queries.forEach((query, component) => {\n      const queryWillRun = handleQuery(snapshot, query, component)\n\n      if (queryWillRun) {\n        watchComponent(component)\n      } else if (isFirstRun) {\n        report.warn(\n          `The GraphQL query in the non-page component \"${component}\" will not be run.`\n        )\n        queriesWillNotRun = true\n      }\n    })\n\n    if (queriesWillNotRun) {\n      report.log(report.stripIndent`\n        Exported queries are only executed for Page components. Instead of an exported\n        query, either co-locate a GraphQL fragment and compose that fragment into the\n        query (or other fragment) of the top-level page that renders this component, or\n        use a <StaticQuery> in this component. For more info on fragments and\n        composition, see http://graphql.org/learn/queries/#fragments and for more\n        information on <StaticQuery>, see https://next.gatsbyjs.org/docs/static-query\n      `)\n    }\n    runQueuedQueries()\n  })\n}\n\n/**\n * Removes components templates that aren't used by any page from redux store.\n */\nconst clearInactiveComponents = () => {\n  const { components, pages } = store.getState()\n\n  const activeTemplates = new Set()\n  pages.forEach(page => {\n    // Set will guarantee uniqeness of entires\n    activeTemplates.add(slash(page.component))\n  })\n\n  components.forEach(component => {\n    if (!activeTemplates.has(component.componentPath)) {\n      debug(\n        `${\n          component.componentPath\n        } component was removed because it isn't used by any page`\n      )\n      store.dispatch({\n        type: `REMOVE_TEMPLATE_COMPONENT`,\n        payload: component,\n      })\n    }\n  })\n}\n\nexports.extractQueries = () => {\n  // Remove template components that point to not existing page templates.\n  // We need to do this, because components data is cached and there might\n  // be changes applied when development server isn't running. This is needed\n  // only in initial run, because during development state will be adjusted.\n  clearInactiveComponents()\n\n  return updateStateAndRunQueries(true).then(() => {\n    // During development start watching files to recompile & run\n    // queries on the fly.\n    if (process.env.NODE_ENV !== `production`) {\n      watch(store.getState().program.directory)\n    }\n  })\n}\n\nconst queueQueriesForPageComponent = componentPath => {\n  const pages = getPagesForComponent(componentPath)\n  // Remove page data dependencies before re-running queries because\n  // the changing of the query could have changed the data dependencies.\n  // Re-running the queries will add back data dependencies.\n  boundActionCreators.deleteComponentsDependencies(\n    pages.map(p => p.path || p.id)\n  )\n  pages.forEach(page => queueQueryForPathname(page.path))\n}\n\nconst getPagesForComponent = componentPath => {\n  const state = store.getState()\n  return [...state.pages.values()].filter(\n    p => p.componentPath === componentPath\n  )\n}\n\nconst filesToWatch = new Set()\nlet watcher\nconst watchComponent = componentPath => {\n  // We don't start watching until mid-way through the bootstrap so ignore\n  // new components being added until then. This doesn't affect anything as\n  // when extractQueries is called from bootstrap, we make sure that all\n  // components are being watched.\n  if (\n    process.env.NODE_ENV !== `production` &&\n    !filesToWatch.has(componentPath)\n  ) {\n    filesToWatch.add(componentPath)\n    if (watcher) {\n      watcher.add(componentPath)\n    }\n  }\n}\n\nexports.watchComponent = watchComponent\n\nconst watch = rootDir => {\n  if (watcher) return\n  const debounceCompile = _.debounce(() => {\n    updateStateAndRunQueries()\n  }, 100)\n\n  watcher = chokidar\n    .watch(slash(path.join(rootDir, `/src/**/*.{js,jsx,ts,tsx}`)))\n    .on(`change`, path => {\n      debounceCompile()\n    })\n  filesToWatch.forEach(filePath => watcher.add(filePath))\n}\n\nif (process.env.gatsby_executing_command === `develop`) {\n  let bootstrapFinished = false\n  emitter.on(`BOOTSTRAP_FINISHED`, () => {\n    bootstrapFinished = true\n  })\n  emitter.on(`DELETE_PAGE`, action => {\n    if (bootstrapFinished) {\n      const componentPath = slash(action.payload.component)\n      const { pages } = store.getState()\n      let otherPageWithTemplateExists = false\n      for (let page of pages.values()) {\n        if (slash(page.component) === componentPath) {\n          otherPageWithTemplateExists = true\n          break\n        }\n      }\n      if (!otherPageWithTemplateExists) {\n        store.dispatch({\n          type: `REMOVE_TEMPLATE_COMPONENT`,\n          payload: {\n            componentPath,\n          },\n        })\n      }\n    }\n  })\n}\n"],"file":"query-watcher.js"}