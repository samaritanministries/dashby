{"version":3,"sources":["../../src/schema/run-sift.js"],"names":["sift","require","_","connectionFromArray","createPageDependency","prepareRegex","Promise","trackInlineObjectsInRootNode","getNode","resolvedNodesCache","Map","enhancedNodeCache","enhancedNodePromiseCache","enhancedNodeCacheId","node","args","internal","contentDigest","JSON","stringify","nodeid","id","digest","awaitSiftField","fields","k","field","resolve","fieldName","undefined","module","exports","nodes","type","typeName","connection","path","clonedArgs","parse","siftifyArgs","object","newObject","each","v","isPlainObject","Minimatch","mm","makeRe","extractFieldsToSift","prekey","key","preobj","obj","val","forEach","siftArgs","fieldsToSift","filter","includes","push","resolveRecursive","siftFieldsObj","gqFields","all","keys","map","then","innerSift","innerGqConfig","isObject","isFunction","getFields","resolvedFields","myNode","Object","length","nodeId","nodesPromise","nodesCacheKey","nodesLength","process","env","NODE_ENV","has","get","cacheKey","enhancedNodeGenerationPromise","resolvedNode","set","resolvedNodes","tempPromise","myNodes","index","isEmpty","indexOf","$and","result","sort","convertedFields","replace","orderBy","order","connectionArray","totalCount"],"mappings":"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","sourcesContent":["// @flow\nconst sift = require(`sift`)\nconst _ = require(`lodash`)\nconst { connectionFromArray } = require(`graphql-skip-limit`)\nconst { createPageDependency } = require(`../redux/actions/add-page-dependency`)\nconst prepareRegex = require(`./prepare-regex`)\nconst Promise = require(`bluebird`)\nconst { trackInlineObjectsInRootNode } = require(`./node-tracking`)\nconst { getNode } = require(`../redux`)\n\nconst resolvedNodesCache = new Map()\nconst enhancedNodeCache = new Map()\nconst enhancedNodePromiseCache = new Map()\nconst enhancedNodeCacheId = ({ node, args }) =>\n  node && node.internal && node.internal.contentDigest\n    ? JSON.stringify({\n        nodeid: node.id,\n        digest: node.internal.contentDigest,\n        ...args,\n      })\n    : null\n\nfunction awaitSiftField(fields, node, k) {\n  const field = fields[k]\n  if (field.resolve) {\n    return field.resolve(\n      node,\n      {},\n      {},\n      {\n        fieldName: k,\n      }\n    )\n  } else if (node[k] !== undefined) {\n    return node[k]\n  }\n\n  return undefined\n}\n\n/*\n * Filters a list of nodes using mongodb-like syntax.\n * Returns a single unwrapped element if connection = false.\n *\n */\nmodule.exports = ({\n  args,\n  nodes,\n  type,\n  typeName,\n  connection = false,\n  path = ``,\n}: Object) => {\n  // Clone args as for some reason graphql-js removes the constructor\n  // from nested objects which breaks a check in sift.js.\n  const clonedArgs = JSON.parse(JSON.stringify(args))\n\n  const siftifyArgs = object => {\n    const newObject = {}\n    _.each(object, (v, k) => {\n      if (_.isPlainObject(v)) {\n        if (k === `elemMatch`) {\n          k = `$elemMatch`\n        }\n        newObject[k] = siftifyArgs(v)\n      } else {\n        // Compile regex first.\n        if (k === `regex`) {\n          newObject[`$regex`] = prepareRegex(v)\n        } else if (k === `glob`) {\n          const Minimatch = require(`minimatch`).Minimatch\n          const mm = new Minimatch(v)\n          newObject[`$regex`] = mm.makeRe()\n        } else {\n          newObject[`$${k}`] = v\n        }\n      }\n    })\n    return newObject\n  }\n\n  // Build an object that excludes the innermost leafs,\n  // this avoids including { eq: x } when resolving fields.\n  function extractFieldsToSift(prekey, key, preobj, obj, val) {\n    if (_.isPlainObject(val)) {\n      _.forEach((val: any), (v, k) => {\n        preobj[prekey] = obj\n        extractFieldsToSift(key, k, obj, {}, v)\n      })\n    } else {\n      preobj[prekey] = true\n    }\n  }\n\n  const siftArgs = []\n  const fieldsToSift = {}\n  if (clonedArgs.filter) {\n    _.each(clonedArgs.filter, (v, k) => {\n      // Ignore connection and sorting args.\n      if (_.includes([`skip`, `limit`, `sort`], k)) return\n\n      siftArgs.push(\n        siftifyArgs({\n          [k]: v,\n        })\n      )\n      extractFieldsToSift(``, k, {}, fieldsToSift, v)\n    })\n  }\n\n  // Resolves every field used in the node.\n  function resolveRecursive(node, siftFieldsObj, gqFields) {\n    return Promise.all(\n      _.keys(siftFieldsObj).map(k =>\n        Promise.resolve(awaitSiftField(gqFields, node, k))\n          .then(v => {\n            const innerSift = siftFieldsObj[k]\n            const innerGqConfig = gqFields[k]\n            if (\n              _.isObject(innerSift) &&\n              v != null &&\n              innerGqConfig &&\n              innerGqConfig.type &&\n              _.isFunction(innerGqConfig.type.getFields)\n            ) {\n              return resolveRecursive(\n                v,\n                innerSift,\n                innerGqConfig.type.getFields()\n              )\n            } else {\n              return v\n            }\n          })\n          .then(v => [k, v])\n      )\n    ).then(resolvedFields => {\n      const myNode = {\n        ...node,\n      }\n      resolvedFields.forEach(([k, v]) => (myNode[k] = v))\n      return myNode\n    })\n  }\n\n  // If the the query only has a filter for an \"id\", then we'll just grab\n  // that ID and return it.\n  if (\n    Object.keys(fieldsToSift).length === 1 &&\n    Object.keys(fieldsToSift)[0] === `id`\n  ) {\n    const node = resolveRecursive(\n      getNode(siftArgs[0].id[`$eq`]),\n      fieldsToSift,\n      type.getFields()\n    )\n\n    if (node) {\n      createPageDependency({\n        path,\n        nodeId: node.id,\n      })\n    }\n\n    return node\n  }\n\n  const nodesPromise = () => {\n    const nodesCacheKey = JSON.stringify({\n      // typeName + count being the same is a pretty good\n      // indication that the nodes are the same.\n      typeName,\n      nodesLength: nodes.length,\n      ...fieldsToSift,\n    })\n    if (\n      process.env.NODE_ENV === `production` &&\n      resolvedNodesCache.has(nodesCacheKey)\n    ) {\n      return Promise.resolve(resolvedNodesCache.get(nodesCacheKey))\n    } else {\n      return Promise.all(\n        nodes.map(node => {\n          const cacheKey = enhancedNodeCacheId({\n            node,\n            args: fieldsToSift,\n          })\n          if (cacheKey && enhancedNodeCache.has(cacheKey)) {\n            return Promise.resolve(enhancedNodeCache.get(cacheKey))\n          } else if (cacheKey && enhancedNodePromiseCache.has(cacheKey)) {\n            return enhancedNodePromiseCache.get(cacheKey)\n          }\n\n          const enhancedNodeGenerationPromise = new Promise(resolve => {\n            resolveRecursive(node, fieldsToSift, type.getFields()).then(\n              resolvedNode => {\n                trackInlineObjectsInRootNode(resolvedNode)\n                if (cacheKey) {\n                  enhancedNodeCache.set(cacheKey, resolvedNode)\n                }\n                resolve(resolvedNode)\n              }\n            )\n          })\n          enhancedNodePromiseCache.set(cacheKey, enhancedNodeGenerationPromise)\n          return enhancedNodeGenerationPromise\n        })\n      ).then(resolvedNodes => {\n        resolvedNodesCache.set(nodesCacheKey, resolvedNodes)\n        return resolvedNodes\n      })\n    }\n  }\n  const tempPromise = nodesPromise().then(myNodes => {\n    if (!connection) {\n      const index = _.isEmpty(siftArgs)\n        ? 0\n        : sift.indexOf(\n            {\n              $and: siftArgs,\n            },\n            myNodes\n          )\n\n      // If a node is found, create a dependency between the resulting node and\n      // the path.\n      if (index !== -1) {\n        createPageDependency({\n          path,\n          nodeId: myNodes[index].id,\n        })\n\n        return myNodes[index]\n      } else {\n        return null\n      }\n    }\n\n    let result = _.isEmpty(siftArgs)\n      ? myNodes\n      : sift(\n          {\n            $and: siftArgs,\n          },\n          myNodes\n        )\n\n    if (!result || !result.length) return null\n\n    // Sort results.\n    if (clonedArgs.sort) {\n      // create functions that return the item to compare on\n      // uses _.get so nested fields can be retrieved\n      const convertedFields = clonedArgs.sort.fields\n        .map(field => field.replace(/___/g, `.`))\n        .map(field => v => _.get(v, field))\n\n      result = _.orderBy(result, convertedFields, clonedArgs.sort.order)\n    }\n\n    const connectionArray = connectionFromArray(result, args)\n    connectionArray.totalCount = result.length\n    if (result.length > 0 && result[0].internal) {\n      createPageDependency({\n        path,\n        connection: result[0].internal.type,\n      })\n    }\n    return connectionArray\n  })\n\n  return tempPromise\n}\n"],"file":"run-sift.js"}