{"version":3,"sources":["../../src/utils/cache.js"],"names":["Promise","require","fs","_","objectToMap","obj","Map","Object","entries","mapToObject","map","key","value","db","directory","save","exports","initCache","ensureDirSync","process","cwd","env","NODE_ENV","tmpdir","previousState","JSON","parse","readFileSync","e","get","resolve","reject","set","debounce","writeFile","stringify","noop"],"mappings":";;AAAA,MAAMA,UAAUC,QAAS,UAAT,CAAhB;;AACA,MAAMC,KAAKD,QAAS,UAAT,CAAX;;AACA,MAAME,IAAIF,QAAS,QAAT,CAAV;;AAEA,MAAMG,cAAcC,OAAO,IAAIC,GAAJ,CAAQC,OAAOC,OAAP,CAAeH,GAAf,CAAR,CAA3B;;AAEA,MAAMI,cAAcC,OAAO;AACzB,QAAML,MAAM,EAAZ;;AACA,uBAAyBK,GAAzB,kHAA8B;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,QAApBC,GAAoB;AAAA,QAAfC,KAAe;AAC5BP,QAAIM,GAAJ,IAAWC,KAAX;AACD;;AACD,SAAOP,GAAP;AACD,CAND;;AAQA,IAAIQ,EAAJ;AACA,IAAIC,SAAJ;AACA,IAAIC,IAAJ;AAEA;;;;AAGAC,QAAQC,SAAR,GAAoB,MAAM;AACxBf,KAAGgB,aAAH,CAAkB,GAAEC,QAAQC,GAAR,EAAc,eAAlC;;AACA,MAAID,QAAQE,GAAR,CAAYC,QAAZ,KAA0B,MAA9B,EAAqC;AACnCR,gBAAYb,QAAS,IAAT,EAAcsB,MAAd,EAAZ;AACD,GAFD,MAEO;AACLT,gBAAYK,QAAQC,GAAR,KAAiB,eAA7B;AACD;;AAED,MAAII,aAAJ;;AACA,MAAI;AACFA,oBAAgBC,KAAKC,KAAL,CAAWxB,GAAGyB,YAAH,CAAiB,GAAEb,SAAU,UAA7B,CAAX,CAAhB;AACD,GAFD,CAEE,OAAOc,CAAP,EAAU,CACV;AACD;;AAED,MAAIJ,aAAJ,EAAmB;AACjBX,SAAKT,YAAYoB,aAAZ,CAAL;AACD,GAFD,MAEO;AACLX,SAAK,IAAIP,GAAJ,EAAL;AACD;AACF,CApBD;AAsBA;;;;;;;AAKAU,QAAQa,GAAR,GAAclB,OACZ,IAAIX,OAAJ,CAAY,CAAC8B,OAAD,EAAUC,MAAV,KAAqB;AAC/BD,UAAQjB,GAAGgB,GAAH,CAAOlB,GAAP,CAAR;AACD,CAFD,CADF;AAKA;;;;;;;;AAMAK,QAAQgB,GAAR,GAAc,CAACrB,GAAD,EAAMC,KAAN,KACZ,IAAIZ,OAAJ,CAAY,CAAC8B,OAAD,EAAUC,MAAV,KAAqB;AAC/BlB,KAAGmB,GAAH,CAAOrB,GAAP,EAAYC,KAAZ;AACAG;AACAe,UAAS,IAAT;AACD,CAJD,CADF;;AAOA,IAAIX,QAAQE,GAAR,CAAYC,QAAZ,KAA0B,MAA9B,EAAqC;AACnCP,SAAOZ,EAAE8B,QAAF,CAAW,MAAM;AACtB/B,OAAGgC,SAAH,CAAc,GAAEpB,SAAU,UAA1B,EAAqCW,KAAKU,SAAL,CAAe1B,YAAYI,EAAZ,CAAf,CAArC;AACD,GAFM,EAEJ,GAFI,CAAP;AAGD,CAJD,MAIO;AACLE,SAAOZ,EAAEiC,IAAT;AACD","sourcesContent":["const Promise = require(`bluebird`)\nconst fs = require(`fs-extra`)\nconst _ = require(`lodash`)\n\nconst objectToMap = obj => new Map(Object.entries(obj))\n\nconst mapToObject = map => {\n  const obj = {}\n  for (let [key, value] of map) {\n    obj[key] = value\n  }\n  return obj\n}\n\nlet db\nlet directory\nlet save\n\n/**\n * Initialize cache store. Reuse existing store if available.\n */\nexports.initCache = () => {\n  fs.ensureDirSync(`${process.cwd()}/.cache/cache`)\n  if (process.env.NODE_ENV === `test`) {\n    directory = require(`os`).tmpdir()\n  } else {\n    directory = process.cwd() + `/.cache/cache`\n  }\n\n  let previousState\n  try {\n    previousState = JSON.parse(fs.readFileSync(`${directory}/db.json`))\n  } catch (e) {\n    // ignore\n  }\n\n  if (previousState) {\n    db = objectToMap(previousState)\n  } else {\n    db = new Map()\n  }\n}\n\n/**\n * Get value of key\n * @param key\n * @returns {Promise}\n */\nexports.get = key =>\n  new Promise((resolve, reject) => {\n    resolve(db.get(key))\n  })\n\n/**\n * Create or update key with value\n * @param key\n * @param value\n * @returns {Promise} - Promise object which resolves to 'Ok' if successful.\n */\nexports.set = (key, value) =>\n  new Promise((resolve, reject) => {\n    db.set(key, value)\n    save()\n    resolve(`Ok`)\n  })\n\nif (process.env.NODE_ENV !== `test`) {\n  save = _.debounce(() => {\n    fs.writeFile(`${directory}/db.json`, JSON.stringify(mapToObject(db)))\n  }, 250)\n} else {\n  save = _.noop\n}\n"],"file":"cache.js"}