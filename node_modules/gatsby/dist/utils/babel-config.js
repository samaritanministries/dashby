"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

const apiRunnerNode = require(`./api-runner-node`);

const _require = require(`../redux`),
      store = _require.store;

const buildConfig = (abstractConfig, stage, resolve = require.resolve) => {
  let babelrc = Object.assign({}, abstractConfig.options, {
    presets: [],
    plugins: []
  });
  abstractConfig.presets.forEach(p => babelrc.presets.push([resolve(p.name), p.options]));
  abstractConfig.plugins.forEach(p => babelrc.plugins.push([resolve(p.name), p.options]));

  if (!babelrc.hasOwnProperty(`cacheDirectory`)) {
    babelrc.cacheDirectory = true;
  }

  if (stage === `develop`) {
    // TODO: maybe this should be left to the user?
    babelrc.plugins.unshift(resolve(`react-hot-loader/babel`));
  } // Make dynamic imports work during SSR.


  if (stage === `build-html` || stage === `develop-html`) {
    babelrc.plugins.unshift(resolve(`babel-plugin-dynamic-import-node`));
  }

  babelrc.plugins.unshift(resolve(`babel-plugin-remove-graphql-queries`));
  return babelrc;
};

exports.buildConfig = buildConfig;
/**
 * Returns a normalized Babel config to use with babel-loader. All of
 * the paths will be absolute so that Babel behaves as expected.
 */

exports.createBabelConfig =
/*#__PURE__*/
function () {
  var _babelConfig = (0, _asyncToGenerator2.default)(function* (program, stage) {
    yield apiRunnerNode(`onCreateBabelConfig`, {
      stage
    });
    const babelrcState = store.getState().babelrc;
    let babelrc = buildConfig(babelrcState.stages[stage], stage);
    return babelrc;
  });

  return function babelConfig(_x, _x2) {
    return _babelConfig.apply(this, arguments);
  };
}();
//# sourceMappingURL=babel-config.js.map