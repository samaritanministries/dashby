{"version":3,"sources":["../../../src/internal-plugins/query-runner/query-watcher.js"],"names":["_","require","chokidar","path","slash","store","boundActionCreators","queryCompiler","default","report","queueQueryForPathname","runQueuedQueries","runQueuedActions","debug","getQueriesSnapshot","state","getState","snapshot","components","Map","staticQueryComponents","handleComponentsWithRemovedQueries","queries","forEach","c","query","has","componentPath","replaceComponentQuery","queueQueriesForPageComponent","dispatch","type","payload","jsonName","deleteComponentsDependencies","handleQuery","component","isStaticQuery","isNewQuery","get","text","replaceStaticQuery","name","id","hash","length","updateStateAndRunQueries","isFirstRun","then","queriesWillNotRun","queryWillRun","watchComponent","warn","log","stripIndent","exports","extractQueries","process","env","NODE_ENV","watch","program","directory","pages","getPagesForComponent","map","p","page","values","filter","filesToWatch","Set","watcher","add","rootDir","debounceCompile","debounce","join","on","filePath"],"mappings":"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","sourcesContent":["/** *\n * Jobs of this module\n * - Maintain the list of components in the Redux store. So monitor new components\n *   and add/remove components.\n * - Watch components for query changes and extract these and update the store.\n * - Ensure all page queries are run as part of bootstrap and report back when\n *   this is done\n * - Whenever a query changes, re-run all pages that rely on this query.\n ***/\n\nconst _ = require(`lodash`)\nconst chokidar = require(`chokidar`)\nconst path = require(`path`)\nconst slash = require(`slash`)\n\nconst { store } = require(`../../redux/`)\nconst { boundActionCreators } = require(`../../redux/actions`)\nconst queryCompiler = require(`./query-compiler`).default\nconst report = require(`gatsby-cli/lib/reporter`)\nconst {\n  queueQueryForPathname,\n  runQueuedActions: runQueuedQueries,\n} = require(`./page-query-runner`)\nconst debug = require(`debug`)(`gatsby:query-watcher`)\n\nconst getQueriesSnapshot = () => {\n  const state = store.getState()\n\n  const snapshot = {\n    components: new Map(state.components),\n    staticQueryComponents: new Map(state.staticQueryComponents),\n  }\n\n  return snapshot\n}\n\nconst handleComponentsWithRemovedQueries = (\n  { components, staticQueryComponents },\n  queries\n) => {\n  // If a component previously with a query now doesn't â€” update the\n  // store.\n  components.forEach(c => {\n    if (c.query !== `` && !queries.has(c.componentPath)) {\n      debug(`Page query was removed from ${c.componentPath}`)\n      boundActionCreators.replaceComponentQuery({\n        query: ``,\n        componentPath: c.componentPath,\n      })\n      queueQueriesForPageComponent(c.componentPath)\n    }\n  })\n\n  // If a component had static query and it doesn't have it\n  // anymore - update the store\n  staticQueryComponents.forEach(c => {\n    if (c.query !== `` && !queries.has(c.componentPath)) {\n      debug(`Static query was removed from ${c.componentPath}`)\n      store.dispatch({\n        type: `REMOVE_STATIC_QUERY`,\n        payload: c.jsonName,\n      })\n      boundActionCreators.deleteComponentsDependencies([c.jsonName])\n    }\n  })\n}\n\nconst handleQuery = (\n  { components, staticQueryComponents },\n  query,\n  component\n) => {\n  // If this is a static query\n  // Add action / reducer + watch staticquery files\n  if (query.isStaticQuery) {\n    const isNewQuery = !staticQueryComponents.has(query.jsonName)\n    if (\n      isNewQuery ||\n      staticQueryComponents.get(query.jsonName).query !== query.text\n    ) {\n      boundActionCreators.replaceStaticQuery({\n        name: query.name,\n        componentPath: query.path,\n        id: query.jsonName,\n        jsonName: query.jsonName,\n        query: query.text,\n        hash: query.hash,\n      })\n\n      debug(\n        `Static query in ${component} ${\n          isNewQuery ? `was added` : `has changed`\n        }.`\n      )\n\n      boundActionCreators.deleteComponentsDependencies([query.jsonName])\n      queueQueryForPathname(query.jsonName)\n    }\n    return true\n\n    // If this is page query\n  } else if (components.has(component)) {\n    if (components.get(component).query !== query.text) {\n      boundActionCreators.replaceComponentQuery({\n        query: query.text,\n        componentPath: component,\n      })\n\n      debug(\n        `Page query in ${component} ${\n          components.get(component).query.length === 0\n            ? `was added`\n            : `has changed`\n        }.`\n      )\n      queueQueriesForPageComponent(component)\n    }\n    return true\n  }\n\n  return false\n}\n\nconst updateStateAndRunQueries = isFirstRun => {\n  const snapshot = getQueriesSnapshot()\n  return queryCompiler().then(queries => {\n    handleComponentsWithRemovedQueries(snapshot, queries)\n\n    let queriesWillNotRun = false\n    queries.forEach((query, component) => {\n      const queryWillRun = handleQuery(snapshot, query, component)\n\n      if (queryWillRun) {\n        watchComponent(component)\n      } else if (isFirstRun) {\n        report.warn(\n          `The GraphQL query in the non-page component \"${component}\" will not be run.`\n        )\n        queriesWillNotRun = true\n      }\n    })\n\n    if (queriesWillNotRun) {\n      report.log(report.stripIndent`\n        Queries are only executed for Page components. Instead of a query,\n        co-locate a GraphQL fragment and compose that fragment into the query (or other\n        fragment) of the top-level page that renders this component. For more\n        info on fragments and composition see: http://graphql.org/learn/queries/#fragments\n      `)\n    }\n    runQueuedQueries()\n  })\n}\n\nexports.extractQueries = () =>\n  updateStateAndRunQueries(true).then(() => {\n    // During development start watching files to recompile & run\n    // queries on the fly.\n    if (process.env.NODE_ENV !== `production`) {\n      watch(store.getState().program.directory)\n    }\n  })\n\nconst queueQueriesForPageComponent = componentPath => {\n  const pages = getPagesForComponent(componentPath)\n  // Remove page data dependencies before re-running queries because\n  // the changing of the query could have changed the data dependencies.\n  // Re-running the queries will add back data dependencies.\n  boundActionCreators.deleteComponentsDependencies(\n    pages.map(p => p.path || p.id)\n  )\n  pages.forEach(page => queueQueryForPathname(page.path))\n}\n\nconst getPagesForComponent = componentPath => {\n  const state = store.getState()\n  return [...state.pages.values()].filter(\n    p => p.componentPath === componentPath\n  )\n}\n\nconst filesToWatch = new Set()\nlet watcher\nconst watchComponent = componentPath => {\n  // We don't start watching until mid-way through the bootstrap so ignore\n  // new components being added until then. This doesn't affect anything as\n  // when extractQueries is called from bootstrap, we make sure that all\n  // components are being watched.\n  if (\n    process.env.NODE_ENV !== `production` &&\n    !filesToWatch.has(componentPath)\n  ) {\n    filesToWatch.add(componentPath)\n    if (watcher) {\n      watcher.add(componentPath)\n    }\n  }\n}\n\nexports.watchComponent = watchComponent\n\nconst watch = rootDir => {\n  if (watcher) return\n  const debounceCompile = _.debounce(() => {\n    updateStateAndRunQueries()\n  }, 100)\n\n  watcher = chokidar\n    .watch(slash(path.join(rootDir, `/src/**/*.{js,jsx,ts,tsx}`)))\n    .on(`change`, path => {\n      debounceCompile()\n    })\n  filesToWatch.forEach(filePath => watcher.add(filePath))\n}\n"],"file":"query-watcher.js"}