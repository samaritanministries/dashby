{"version":3,"sources":["../../src/bootstrap/resolve-module-exports.js"],"names":["fs","require","traverse","default","get","module","exports","modulePath","resolver","resolve","absPath","exportNames","err","code","readFileSync","ast","ExportNamedDeclaration","astPath","exportName","push","AssignmentExpression","nodeLeft","node","left","type","property","name"],"mappings":";;AAIA;;AAHA,MAAMA,KAAKC,QAAS,IAAT,CAAX;;AACA,MAAMC,WAAWD,QAAS,gBAAT,EAA0BE,OAA3C;;AACA,MAAMC,MAAMH,QAAS,YAAT,CAAZ;;AAGA;;;;;;;;;AASAI,OAAOC,OAAP,GAAiB,CAACC,UAAD,EAAaC,WAAWP,QAAQQ,OAAhC,KAA4C;AAC3D,MAAIC,OAAJ;AACA,QAAMC,cAAc,EAApB;;AAEA,MAAI;AACFD,cAAUF,SAASD,UAAT,CAAV;AACD,GAFD,CAEE,OAAOK,GAAP,EAAY;AACZ,WAAOD,WAAP,CADY,CACO;AACpB;;AACD,QAAME,OAAOb,GAAGc,YAAH,CAAgBJ,OAAhB,EAA0B,MAA1B,CAAb,CAT2D,CASb;;AAE9C,QAAMK,MAAM,sCAAgBF,IAAhB,EAAsBH,OAAtB,CAAZ,CAX2D,CAa3D;;AACAR,WAASa,GAAT,EAAc;AACZ;AACAC,4BAAwB,SAASA,sBAAT,CAAgCC,OAAhC,EAAyC;AAC/D,YAAMC,aAAad,IACjBa,OADiB,EAEhB,0CAFgB,CAAnB;AAIA,UAAIC,UAAJ,EAAgBP,YAAYQ,IAAZ,CAAiBD,UAAjB;AACjB,KARW;AASZE,0BAAsB,SAASA,oBAAT,CAA8BH,OAA9B,EAAuC;AAC3D,YAAMI,WAAWJ,QAAQK,IAAR,CAAaC,IAA9B;AAEA,UAAIF,SAASG,IAAT,KAAmB,kBAAvB,EAA0C,OAHiB,CAK3D;;AACA,UAAIpB,IAAIiB,QAAJ,EAAe,aAAf,MAAkC,SAAtC,EAAgD;AAC9CV,oBAAYQ,IAAZ,CAAiBE,SAASI,QAAT,CAAkBC,IAAnC;AACD,OAR0D,CAU3D;;;AACA,UACEtB,IAAIiB,QAAJ,EAAe,oBAAf,MAAyC,QAAzC,IACAjB,IAAIiB,QAAJ,EAAe,sBAAf,MAA2C,SAF7C,EAGE;AACAV,oBAAYQ,IAAZ,CAAiBE,SAASI,QAAT,CAAkBC,IAAnC;AACD;AACF;AA1BW,GAAd;AA6BA,SAAOf,WAAP;AACD,CA5CD","sourcesContent":["// @flow\nconst fs = require(`fs`)\nconst traverse = require(`babel-traverse`).default\nconst get = require(`lodash/get`)\nimport { babelParseToAst } from \"../utils/babel-parse-to-ast\"\n\n/**\n * Given a `require.resolve()` compatible path pointing to a JS module,\n * return an array listing the names of the module's exports.\n *\n * Returns [] for invalid paths and modules without exports.\n *\n * @param {string} modulePath\n * @param {function} resolver\n */\nmodule.exports = (modulePath, resolver = require.resolve) => {\n  let absPath\n  const exportNames = []\n\n  try {\n    absPath = resolver(modulePath)\n  } catch (err) {\n    return exportNames // doesn't exist\n  }\n  const code = fs.readFileSync(absPath, `utf8`) // get file contents\n\n  const ast = babelParseToAst(code, absPath)\n\n  // extract names of exports from file\n  traverse(ast, {\n    // get foo from `export const foo = bar`\n    ExportNamedDeclaration: function ExportNamedDeclaration(astPath) {\n      const exportName = get(\n        astPath,\n        `node.declaration.declarations[0].id.name`\n      )\n      if (exportName) exportNames.push(exportName)\n    },\n    AssignmentExpression: function AssignmentExpression(astPath) {\n      const nodeLeft = astPath.node.left\n\n      if (nodeLeft.type !== `MemberExpression`) return\n\n      // get foo from `exports.foo = bar`\n      if (get(nodeLeft, `object.name`) === `exports`) {\n        exportNames.push(nodeLeft.property.name)\n      }\n\n      // get foo from `module.exports.foo = bar`\n      if (\n        get(nodeLeft, `object.object.name`) === `module` &&\n        get(nodeLeft, `object.property.name`) === `exports`\n      ) {\n        exportNames.push(nodeLeft.property.name)\n      }\n    },\n  })\n\n  return exportNames\n}\n"],"file":"resolve-module-exports.js"}